(coll? '(1 2 3))
(coll? '(1 2 3) :a)
(coll? '(1 2 3) :a :b)
(if coll? '(1 2 3) :a :b)
(if (coll? '(1 2 3)) :a :b)
(if (coll? 1) :a :b)
((fn [sep, elems] (conj (flatten (map #(list %1 sep) (rest elems))) (first elems))) 0 [1 2 3])
((fn [l n] (filter nil? (map-indexed (fn [k v] (if (mod k n) nil v)) l))) [1,2,3,4,5,6,7,8,9,0] 2)
((fn [l n] (filter nil? (map-indexed (fn [k v] (if (= 0 (mod k n)) nil v)) l))) [1,2,3,4,5,6,7,8,9] 2)
((fn [l n] (filter nil? (map-indexed (fn [k v] (if (= 0 (mod n k)) nil v)) l))) [1,2,3,4,5,6,7,8,9] 2)
((fn [l n] (filter nil? (map-indexed (fn [k v] (if (= 0 (mod k n)) nil v)) l))) [1,2,3,4,5,6,7,8,9] 2)
((fn [l n] (filter nil? (map-indexed (fn [k v] (if (= 0 (mod (+ k 1) n)) nil v)) l))) [1,2,3,4,5,6,7,8,9] 2)
((fn [l n] (filter (not nil?) (map-indexed (fn [k v] (if (= 0 (mod (+ k 1) n)) nil v)) l))) [1,2,3,4,5,6,7,8,9] 2)
((fn [l n] (filter (partial not= 0) (map-indexed (fn [k v] (if (= 0 (mod (+ k 1) n)) nil v)) l))) [1,2,3,4,5,6,7,8,9] 2)
((fn [l n] (filter (partial not= nil) (map-indexed (fn [k v] (if (= 0 (mod (+ k 1) n)) nil v)) l))) [1,2,3,4,5,6,7,8,9] 2)
:a {:b 1 :c nil}
(:a {:b 1 :c nil})
([let x {:b 1 :c nil}])
(let [x {:b 1 :c nil}])
(#(and (contains? %1 %2) (nil? (%2 %1))) :a {:a nil :b 2})
(#(and (contains? %2 %1) (nil? (%2 %1))) :a {:a nil :b 2})
(#(%) :a {:a nil :b 2})
(#(not (% %1 1) :a {:a nil :b 2})
(#(not (% %1 1)) :a {:a nil :b 2})
(#(not (%2 %1 1)) :a {:a nil :b 2})
(#(not (%2 % 1)) :a {:a nil :b 2})
(#(not (%2 %)) :a {:a nil :b 2})
(#(not (%2 % false)) :a {:a nil :b 2})
(#(not (%2 % false cocks)) :a {:a nil :b 2})
(#(not (%2 % false :cocks)) :a {:a nil :b 2})
(#(not (%2 % false)) :a {:a nil :b 2})
(((fn [d l] (flatten (map #(list %1 d) l))) 0 [:a :b :c])
)
(((fn [d l] (flatten (map #(list %1 d) l)))) 0 [:a :b :c])
(((fn [d l] (flatten (map #(list % d) l)))) 0 [:a :b :c])
((fn [d l] (flatten (map #(list % d) l))) 0 [:a :b :c])
((fn [d l] (flatten (map #(hash-map % d) l))) 0 [:a :b :c])
((fn [d l] (map #(assoc %1 %2 d) {} l))  0 [:a :b :c])
((fn [d l] (map #(assoc %2 %1 d) {} l))  0 [:a :b :c])
((fn [d l] (map #(assoc %1 %2 d) {} l))  0 [:a :b :c])
((fn [d l] (redice #(assoc %1 %2 d) {} l)) 0 [:a :b :c])
((fn [d l] (reduce #(assoc %1 %2 d) {} l)) 0 [:a :b :c])
((fn [x] apply str (re-matches #"[A-Z]" x)), "aAbB")
((fn [x] apply str (re-find #"[A-Z]" x)), "aAbB")
((fn [x] str (re-find #"[A-Z]" x)), "aAbB")
((fn [x] str (re-find #"[A-Z]" x)), "aAbBCDe")
((fn [x] (apply str (re-find #"[A-Z]" x))), "aAbBCDe")
((fn [x] (apply str (re-swq #"[A-Z]" x))), "aAbBCDe")
((fn [x] (apply str (re-seq #"[A-Z]" x))), "aAbBCDe")
((fn [x] apply str (re-seq #"[A-Z]" x)), "aAbBCDe")
((fn [x] (apply str (re-seq #"[A-Z]" x))), "aAbBCDe")
((fn [x] reduce #(conj %2 %1 %1) [] x) [:a :b :c])
((fn [x] reduce #(conj %1 %2 %2) [] x) [:a :b :c])
((fn [x] (reduce #(conj %1 %2 %2) [] x)) [:a :b :c])
((fn flat [l] (reduce #(conj %1 (if (coll? %2) (flat %2) %2)) [] l)) '((1 2) 3 [4 [5 6]]))
((fn flat [l] (reduce #(apply conj %1 (if (coll? %2) (flat %2) %2)) [] l)) '((1 2) 3 [4 [5 6]]))
((fn flat [l] (reduce #(apply conj %1 (if (coll? %2) (flat %2) [%2])) [] l)) '((1 2) 3 [4 [5 6]]))
(take 4 (iter 4 1))
(take 4 (iterate 4 1))
(take 4 (iterate #(4) 1))
(take 4 (iterate #(%) 1))
(take 4 (iterate #(+ 1 %) 1))
(take 4 (iterate #(ret %) 1))
(#(reduce conj [] (map (partial repeat %2) %1)) [1 2 3] 3)
(#(reduce merge [] (map (partial repeat %2) %1)) [1 2 3] 3)
(#(reduce cons [] (map (partial repeat %2) %1)) [1 2 3] 3)
(#(reduce (apply conj) [] (map (partial repeat %2) %1)) [1 2 3] 3)
(#(reduce (fn [a b] (apply conj a b)) [] (map (partial repeat %2) %1)) [1 2 3] 3)
nil
true
false
inc
(inc 1 2)
(inc 3)
'inc
(inc 0)
(inc (inc (inc 0)))
(type 3)
(*)
(* 2)
(* 1-)
(* 10)
(re-find #"cat" "thiscatiscattastic")
(re-matches #"cat" "thiscatiscattastic")
(re-matches #".*cat.*" "thiscatiscattastic")
(re-matches #".*cat(.*)" "thiscatiscattastic")
(name str)
(name 'str)
(conj (1 2 3) 4)
(conj '(1 2 3) 4)
(2 '(1 2 3 4))
(nth '(1 2 3 4) 3)
(1 [1 2 3 4])
([1 2 3 4] 1)
{"this" 1 "that" 3}
("this" {"this" 1 "that" 3})
({"this" 1 "that" 3} "this")
({"this" 1 "that" 3} "that")
+
balls
(let [+ -] (+ 1 3))
(meta 'add)
(meta add)
(meta #-add)
(meta #'add)
(meta inc)
(meta 'inc)
(meta '#inc)
(meta #'inc)
(defn test [set-a set-b] (filter (fn [x] (contains? set-b x)) set-a))
(test #{1 2 3 4} #{3 4 5 6})
(test #{8 6 1 2 3 4} #s{3 4 5 6})
(test #{8 6 1 2 3 4} #{3 4 5 6})
(= (test #{0 1 2 3} #{2 3 4 5}) #{2 3})
(test #{0 1 2 3} #{2 3 4 5})
(list "0101000101")
(each "0101000101")
(split "0101000101")
(clojure.string/split "2123234")
(clojure.string/split "2123234" "")
(clojure.string/split "2123234" #"")
(clojure.string/split "12345" #"")
(filter #(= "" %) (clojure.string/split "12345" #""))
(filter #(=! "" %) (clojure.string/split "12345" #""))
(filter #(!= "" %) (clojure.string/split "12345" #""))
(filter #(not= "" %) (clojure.string/split "12345" #""))
(def binarize (fn [x] )
  (let [split-string (filter (fn [a] (not= "" a)) (clojure.string/split x #""))
        numbers (map (fn [a] (if (= "1" a) 1 0)) split-string)]
    (loop [position (dec (count numbers))
           digit (first numbers)
           numbers (rest numbers)
           accum 0]
      (if (empty? numbers)
        accum
        (recur (dec position) (first numbers) (rest numbers) (* digit (Math/pow 2 position)))))))
(defn binarize [x] 
  (let [split-string (filter (fn [a] (not= "" a)) (clojure.string/split x #""))
        numbers (map (fn [a] (if (= "1" a) 1 0)) split-string)]
    (loop [position (dec (count numbers))
           digit (first numbers)
           numbers (rest numbers)
           accum 0]
      (if (empty? numbers)
        accum
        (recur (dec position) (first numbers) (rest numbers) (* digit (Math/pow 2 position)))))))
(binarize "000")
(binarize "001")
(binarize "002")
(binarize "111")
(binarize "1111")
(binarize "1111111")
(binarize "1111110001")
(binarize "11101110001")
(defn binarize [x] 
  (let [split-string (filter (fn [a] (not= "" a)) (clojure.string/split x #""))
        numbers (map (fn [a] (if (= "1" a) 1 0)) split-string)]
    (println split-string)
    (loop [position (dec (count numbers))
           digit (first numbers)
           numbers (rest numbers)
           accum 0]
      (if (empty? numbers)
        accum
        (recur (dec position) (first numbers) (rest numbers) (* digit (Math/pow 2 position)))))))
(binarize "1111110001")
(defn binarize [x] 
  (let [split-string (filter (fn [a] (not= "" a)) (clojure.string/split x #""))
        numbers (map (fn [a] (if (= "1" a) 1 0)) split-string)]
    (println numbers)
    (loop [position (dec (count numbers))
           digit (first numbers)
           numbers (rest numbers)
           accum 0]
      (if (empty? numbers)
        accum
        (recur (dec position) (first numbers) (rest numbers) (* digit (Math/pow 2 position)))))))
(binarize "1111110001")
(def juny (range 1 30))
juny
(def juny (range 1 31))
juny
(def festa '(6 7 13 14 20 21 27 28))
(defn days-left [today]
(let [juny (range 1 31)
festa '(6 7 13 14 20 21 27 28)]
(filter (fn [day] (> day today)) (difference juny festa)))
)
(defn days-left [today]
(let [juny (range 1 31)
festa '(6 7 13 14 20 21 27 28)]
(filter (fn [day] (> day today)) (difference juny festa))))
(defn days-left [today]
(let [juny (set (range 1 31))
festa (set '(6 7 13 14 20 21 27 28))]
(filter (fn [day] (> day today)) (set/difference juny festa))))
(set 1 2 3)
(set '(1 2 3))
(defn days-left [today]
(let [juny (set (range 1 31))
festa (set '(6 7 13 14 20 21 27 28))]
(filter (fn [day] (> day today)) (clojure.set/difference juny festa))))
(days-left 1)
(count (days-left 1))
(count (days-left 15))
(count (days-left 28))
(count (days-left 30))
(count (days-left 345))
(count (days-left 1))
(count (days-left 2))
(count (days-left 3))
(count (days-left 4))
(count (days-left 5))
(count (days-left 6))
(count (days-left 7))
(count (days-left 8))
(count (days-left 1))
(require [clojure.xml :as xml])
(require '[clojure.xml :as xml])
(xml/parse "<a><b /></a>"
)
(count (days-left 6))
(defn days-left [today]
(let [juny (set (range 1 31))
festa (set '(6 7 13 14 20 21 27 28))]
(filter (fn [day] (> day today)) (clojure.set/difference juny festa))))
(count (days-left 3))
(println (iterate + 0))
(println (iterate inc 0))
